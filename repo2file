#!/bin/bash

# Error codes as named constants
declare -r ERR_CODE=1
declare -r INTERRUPT_CODE=2
declare -r DEP_MISSING_CODE=3
declare -r OUTPUT_FILE_ERR_CODE=4
declare -r GIT_REPO_ERR_CODE=5
declare -r FILE_ACCESS_ERR_CODE=6
declare -r EMPTY_DIR_ERR_CODE=7
declare -r DIR_CREATION_ERR_CODE=8

declare -r SCRIPT_NAME=$(basename "$0")
declare -r WORKING_DIR=$(pwd)

declare verbose=0 quiet=0 progress=0 use_gitignore=0
declare exclude_patterns=()
declare exclude_regex=""
declare temp_dir=""
declare output_file_name="repo2file.md"

trap "cleanup; printf 'An error occurred.\n'; exit $ERR_CODE" ERR
trap "cleanup; printf 'Script interrupted.\n'; exit $INTERRUPT_CODE" INT TERM SIGHUP

cleanup() {
    # Ensure temp_dir is not unset or empty
    [[ -n "$temp_dir" && -d "$temp_dir" ]] && rm -rf "$temp_dir"
}

# Dependency check function
check_dependencies() {
    local dependencies=('git' 'file' 'tree')
    local missing_deps=()
    local install_cmd=""

    for dep in "${dependencies[@]}"; do
        command -v "$dep" >/dev/null || missing_deps+=("$dep")
    done

    if [ ${#missing_deps[@]} -ne 0 ]; then
        printf "Missing dependencies: ${missing_deps[*]}\n"
        read -p "Do you want to install them? (y/n): " response
        if [[ "$response" =~ ^[Yy]$ ]]; then
            if [[ "$OSTYPE" == "linux-gnu"* ]]; then
                install_cmd="sudo apt-get install -y"
            elif [[ "$OSTYPE" == "darwin"* ]]; then
                install_cmd="brew install"
            fi
            echo "$install_cmd ${missing_deps[*]}"
            eval "$install_cmd ${missing_deps[*]}"
        else
            exit $DEP_MISSING_CODE
        fi
    fi
}


# Function to check if the script is run from a git repository root
check_git_repository() {
    [ $verbose -eq 1 ] && printf -- "Checking git repository...\n"
    local git_dir=$(git rev-parse --git-dir 2>/dev/null)
    if [[ "$use_gitignore" -eq 1 && -z "$git_dir" ]]; then
        printf -- "This script should be run from the root of a git repository when using --gitignore.\n"
        exit $GIT_REPO_ERR_CODE
    fi
}

# Convert glob patterns to regex
glob_to_regex() {
    # local pattern=$1
    # pattern="${pattern//+/\\+}"     # Escape '+'
    # pattern="${pattern//./\\.}"     # Escape '.'
    # pattern="${pattern//\*/.*}"     # Convert '*' to '.*'
    # pattern="${pattern//\?/.}"      # Convert '?' to '.'
    # echo ".*$pattern.*"
    local pattern=$1
    # Escape special regex characters except '*' and '?'
    pattern=$(sed 's/[]\/$*.^[]/\\&/g' <<< "$pattern")
    # Convert '*' (zero or more of any character)
    pattern="${pattern//\*/.*}"
    # Convert '?' (exactly one of any character)
    pattern="${pattern//\?/.}"
    echo "$pattern"
}

# Compile exclusion regex from patterns
compile_exclusion_regex() {
    exclude_regex=""
    for pattern in "${exclude_patterns[@]}"; do
        local regex_pattern=$(glob_to_regex "$pattern")
        exclude_regex+="$regex_pattern|"
        [ $verbose -eq 1 ] && printf "Compiled regex for pattern '%s': %s\n" "$pattern" "$regex_pattern"
    done
    exclude_regex="${exclude_regex%|}"  # Remove trailing '|'
    [ $verbose -eq 1 ] && printf "Final compiled regex: %s\n" "$exclude_regex"
}


# Function to check if a file is text or binary
is_text_file() {
    local file="$1"
    if file -I "$file" | grep -q 'text/'; then
        return 0  # It's text
    fi
    return 1  # It's binary or unknown
}

# Argument parsing with support for long options
parse_args() {
    while [[ "$#" -gt 0 ]]; do
        case "$1" in
            -h|--help)
                display_help_message; exit 0 ;;
            -v|--verbose)
                [[ $quiet -eq 0 ]] && verbose=1 ;;
            -q|--quiet)
                quiet=1; verbose=0; progress=0 ;;
            -p|--progress)
                [[ $quiet -eq 0 ]] && progress=1 ;;
            -o|--output)
                shift
                if [[ -z "$1" ]]; then
                    printf -- "Error: Output file was not specified.\n"
                    exit $OUTPUT_FILE_ERR_CODE
                fi
                output_file_name="$1"
                if [[ ! -w "$(dirname "$output_file_name")" ]]; then
                    printf -- "Error: Output directory for output file is not writable or does not exist.\n"
                    exit $OUTPUT_FILE_ERR_CODE
                fi
                ;;
            -e|--exclude)
                shift
                if [[ -z "$1" ]]; then
                    printf -- "Error: Exclude pattern was not specified.\n"
                    exit $OUTPUT_FILE_ERR_CODE
                fi
                # exclude_patterns+=("$(glob_to_regex "$1")") ;;
                exclude_patterns+=("$1")
                compile_exclusion_regex
                ;;
            -g|--gitignore)
                use_gitignore=1 ;;
            -*)
                # Handle multiple flags combined e.g., -vg
                local combined_flags="${1#-}"
                for (( i=0; i<${#combined_flags}; i++ )); do
                    case "${combined_flags:i:1}" in
                        v) [[ $quiet -eq 0 ]] && verbose=1 ;;
                        q) quiet=1; verbose=0; progress=0 ;;
                        g) use_gitignore=1 ;;
                        p) [[ $quiet -eq 0 ]] && progress=1 ;;
                        *) printf "Unknown flag: -%s\n" "${combined_flags:i:1}"; exit 0 ;;
                    esac
                done
                ;;
            *)
                printf "Unknown parameter: %s\n" "$1"; display_help_message; exit 0 ;;
        esac
        shift
    done
}

display_help_message() {
    # Use here-doc for multi-line string output
    cat <<-EOF
		Usage: $SCRIPT_NAME [options]

		This script processes the files within a Git repository or a specified directory, checking for text files and appending their contents to a markdown file with an optional directory structure. It's designed to be robust and secure, making use of best practices for Bash scripting.

		Options:
		  -h, --help           Show this help message and exit.
		  -v, --verbose        Enable verbose mode. Prints detailed logs to standard output.
		  -q, --quiet          Disable all output except errors.
		  -p, --progress       Enable progress display, showing a progress bar during execution.
		  -o, --output FILE    Specify the output markdown file where results should be written. Default is 'repo2file.md' in the current directory.
		  -e, --exclude PATTERN Exclude files or directories that match this pattern. Can be specified multiple times.
		  -g, --gitignore      Apply .gitignore rules for excluding files.

		Examples:
		  ./$SCRIPT_NAME                          # Runs the script in the current directory with default settings.
		  ./$SCRIPT_NAME --output results.md      # Runs the script and outputs to 'results.md'.
		  ./$SCRIPT_NAME -v -p --exclude '*.tmp'  # Runs the script in verbose mode, shows progress, and excludes files matching '*.tmp'.
		  ./$SCRIPT_NAME -g                       # Applies .gitignore rules when processing files.

		EOF
}

# Replicate the project in a temporary directory
create_temp_dir() {
    local file_list=("$@")
    [ $verbose -eq 1 ] && printf "Creating temporary directory\n"
    temp_dir=$(mktemp -d) || { printf "Error creating temporary directory.\n"; exit $ERR_CODE; }

    for file in "${file_list[@]}"; do
        temp_file_dir="$temp_dir/$(dirname "$file")"
        mkdir -p "$temp_file_dir" || { printf "Error creating directory: %s\n" "$temp_file_dir"; exit $DIR_CREATION_ERR_CODE; }
        [ $verbose -eq 1 ] && printf "Copying file: %s\n" "$file"
        cp "$file" "$temp_file_dir" || { printf "Error copying file: %s\n" "$file"; exit $FILE_ACCESS_ERR_CODE; }
    done

    [ $verbose -eq 1 ] && printf "Finished replicating project\n"
}

# Function to collect and filter files based on exclude patterns
collect_files() {
    local files=()
    
    
    # Collect the files
    if [[ $use_gitignore -eq 1 ]]; then
        files=($(git -C "$WORKING_DIR" ls-files -co --exclude-from <(git -C "$WORKING_DIR" check-ignore *) | grep -vE "$output_file_name|.gitignore|$SCRIPT_NAME" || exit $EMPTY_DIR_ERR_CODE))
    else
        files=($(git -C "$WORKING_DIR" ls-files -co --exclude-standard | grep -vE "$output_file_name|.gitignore|$SCRIPT_NAME" || exit $EMPTY_DIR_ERR_CODE))
    fi

    if [[ -n "$exclude_regex" ]]; then
        local filtered_files=()
        for file in "${files[@]}"; do
            if ! [[ "$file" =~ $exclude_regex ]]; then
                filtered_files+=("$file")
            fi
        done
        files=("${filtered_files[@]}")
    fi

    printf "${files[*]}"
}

# Function to append the header to the output file
append_header() {
    [ $verbose -eq 1 ] && printf -- "Initializing %s\n" "$output_file_name"
    {
        printf -- "# Project Codebase\n"
        printf -- "Root directory: %s\n" "$(pwd)"
        printf -- "---\n"
    } > "$output_file_name"
}

# Function to append the project tree to the output file
append_directory_structure() {
    [ $verbose -eq 1 ] && [ $quiet -eq 0 ] && printf -- "Appending directory structure to %s\n" "$output_file_name"
    {
        printf -- "## Directory structure:\n"
        printf -- "\`\`\`\n"
        tree "."
        printf -- "\`\`\`\n\n"
        printf -- "---\n"
    } >> "$output_file_name"
}

# Function to append the file contents to the output file
append_file_content() {
    local relative_file_path=$1
    local full_file_path="$temp_dir/$relative_file_path"

    # Check if the file is text
    if ! is_text_file "$full_file_path"; then
        [ $verbose -eq 1 ] && printf "Skipping binary or unsupported file: %s\n" "$relative_file_path"
        return
    fi

    # Check if the file exists and is readable
    [[ ! -f "$full_file_path" || ! -r "$full_file_path" ]] && printf -- "File %s cannot be read or does not exist.\n" "$full_file_path" && return
    
    [ $verbose -eq 1 ] && printf "Appending file: %s\n" "$relative_file_path"

    # Append the file content to the output file
    printf "## File: %s\n" "$relative_file_path" | tee -a "$output_file_name" &>/dev/null
    if [[ "${relative_file_path##*.}" == "md" ]]; then
        printf -- "<!-- [FILE_START]\n" | tee -a "$output_file_name" &>/dev/null
        awk '{ print }' "$full_file_path" | tee -a "$output_file_name" &>/dev/null
        printf -- "\n[FILE_END] -->\n" | tee -a "$output_file_name" &>/dev/null
    else
        printf -- "\`\`\`\n" | tee -a "$output_file_name" &>/dev/null
        awk '{ print }' "$full_file_path" | tee -a "$output_file_name" &>/dev/null
        printf -- "\`\`\`\n\n" | tee -a "$output_file_name" &>/dev/null
    fi
    printf -- "---\n" | tee -a "$output_file_name" &>/dev/null
}

# Process files in the project directory to be appended to the output file
process_files() {
    local temp_dir=$1
    shift
    local file_list=("$@")

    [ $verbose -eq 1 ] && printf -- "Processing %d files...\n" "${#file_list[@]}"

    for file in "${file_list[@]}"; do
        local relative_file_path="${file#"${WORKING_DIR}/"}"
        append_file_content "$relative_file_path"
    done

    [ $progress -eq 1 ] && [ ! $quiet -eq 1 ] && printf -- "\r\033[K[100%%] Done\n"
}

# Entry point of the script
main() {
    parse_args "$@"
    check_dependencies
    check_git_repository
    local file_list=($(collect_files))
    [[ ${#file_list[@]} -eq 0 ]] && { printf "Error: No files to process.\n"; exit $EMPTY_DIR_ERR_CODE; }

    # print the collected file_list
    [ $verbose -eq 1 ] && printf "Collected file_list:\n"
    for file in "${file_list[@]}"; do
        [ $verbose -eq 1 ] && printf "  %s\n" "$file"
    done

    append_header
    append_directory_structure
    create_temp_dir "${file_list[@]}"
    process_files "$temp_dir" "${file_list[@]}"
    cleanup
    [ ! $quiet -eq 1 ] && printf -- "Operation completed. Output stored in %s\n" "$output_file_name"
}

main "$@"
